from os import path, system

from groot.algorithms.classes import IFusion
from groot.data.lego_model import LegoComponent, ILegoVisualisable, LegoSequence
from groot.frontends.gui.gui_view_utils import EChanges
from groot.algorithms import fastaiser, graph_viewing
from groot.data import global_view
from intermake import command, visibilities, EThread, MENV
from mhelper import file_helper, array_helper


_VIS = visibilities.GUI & visibilities.ADVANCED


class VisJsData:
    """
    :attr path:     Path to vis.js.
                    Usually something like `file:///Users/martinrusilowicz/bin/`
    """
    def __init__( self ):
        self.path = ""


__visjs = MENV.local_data.store.bind( "visjs", VisJsData() )


@command( visibility = _VIS )
def refresh( change: EChanges ) -> EChanges:
    """
    Refreshes the GUI
    :param change:  Level of refresh
    """
    return change


@command( visibility = _VIS, threading = EThread.UNMANAGED )
def view_alignments_gui( component: LegoComponent ) -> None:
    """
    Views the alignments in the GUI.
    :param component:   Component to view alignments for
    """
    from groot.frontends.gui.forms.frm_alignment import FrmAlignment
    
    fasta = component.get_alignment_by_accession()
    FrmAlignment.request( MENV.host.form, "Alignment for {}".format( component ), MENV.host.form.view.lookup_table, fasta )


@command( visibility = _VIS, threading = EThread.UNMANAGED )
def view_fasta_gui( entity: ILegoVisualisable ) -> None:
    """
    Views the FASTA in the GUI.
    :param entity:  Entity to view Fasta for
    """
    from groot.frontends.gui.forms.frm_alignment import FrmAlignment
    
    fasta = fastaiser.to_fasta( entity )
    FrmAlignment.request( MENV.host.form, "FASTA for {}".format( entity ), MENV.host.form.view.lookup_table, fasta )


@command( visibility = _VIS )
def view_nrfg_gui( format_str: str = "" ) -> EChanges:
    """
    Views the Nrfg in the Gui.
    :param format_str:  Formatting string. See `print_trees_help`.
    """
    model = global_view.current_model()
    g = [model.nrfg]
    
    return __view_tree_gui( format_str, g, model )


@command( visibility = _VIS )
def view_trees_gui( format_str: str = "" ) -> EChanges:
    """
    Views the Nrfg in the Gui.
    :param format_str:  Formatting string. See `print_trees_help`.
    """
    model = global_view.current_model()
    g = [x.tree for x in model.components]
    
    return __view_tree_gui( format_str, g, model )


def __view_tree_gui( format_str, g, model ):
    HTML_T = file_helper.read_all_text( path.join( file_helper.get_directory( __file__, ), "vis_js_template.html" ) )
    HTML_T = HTML_T.replace( "$(TITLE)", MENV.name + " - " + model.name )
    HTML_T = HTML_T.replace( "$(PATH)", __visjs.path )
    HTML_T = HTML_T.replace( "$(COMMENT)", "File automatically generated by Groot. Please replace this line with your own description." )
    r = []
    formatter = graph_viewing.create_user_formatter( format_str, ansi = False )
    
    all_nodes = [x for gg in g for x in gg.nodes]
    all_edges = [x for gg in g for x in gg.edges]
    
    nodes = array_helper.create_index_lookup( all_nodes )
    for node, node_id in nodes.items():
        # {id: 1, label: 'Node 1'},
        if isinstance( node.data, LegoSequence ):
            component = model.components.find_component_for_major_sequence( node.data )
            colours = ["#C0392B",
                       "#9B59B6",
                       "#2980B9",
                       "#1ABC9C",
                       "#27AE60",
                       "#F1C40F",
                       "#E74C3C",
                       "#8E44AD",
                       "#3498DB",
                       "#239B56",
                       "#16A085",
                       "#2ECC71",
                       "#F39C12",
                       "#D35400"]
            colour = colours[component.index % len( colours )]
        elif isinstance( node.data, IFusion ):
            colour = "#FF0000"
        else:
            colour = "#FFFFC0"
        
        r.append( "{shape:'box', id: " + str( node_id ) + ", label: '" + formatter( node ) + "', color: '" + colour + "'}," )
    HTML_T = HTML_T.replace( "$(NODES)", "\n".join( r ) )
    r = []
    for edge in all_edges:
        # "{from: 1, to: 3},"
        r.append( "{from: " + str( nodes[edge.left] ) + ", to: " + str( nodes[edge.right] ) + ", arrows:'to'}," )
    HTML_T = HTML_T.replace( "$(EDGES)", "\n".join( r ) )
    file_helper.write_all_text( "groot_output.html", HTML_T )
    system( "open groot_output.html" )
    return EChanges.NONE
